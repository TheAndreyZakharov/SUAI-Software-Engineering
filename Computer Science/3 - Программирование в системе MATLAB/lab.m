% шаг интегрирования
dx = 0.001;
% "точность" вычисления ряда
ep = 0.00005;
% Создаем вектор значений аргумента, охватывающий всю ОДЗ функции
x = -3:0.001:0;
% вычисление функции
% создаем переменную i - индекс значений вектора y
i = 0;
% создаем цикл для расчета значений функции, на каждой итерации цикла будет вычисляться i-й элемент вектора y
for x = -3:0.001:0
    i = i + 1;
    if x < -2
        % x лежит на интервале [-3; -2)
        y(i) = 0;
    elseif x < -1
        % x лежит на интервале [-2; -1)
        % производим численное интегрирование
        y(i) = 0;
        for z = -2 : dx : x
            y(i) = y(i) + cos(z) + 1/z;
        end
        y(i) = real (y(i) * dx);
    else
        % x лежит на интервале [-1; 0]
        % производим суммирование ряда
        y(i) = 0;
        % инициализируем член ряда значением большим ep
        x_n = 2 * ep;
        % номер члена ряда
        n = 0;
        % создаем вспомогательные переменные для вычисления факториала и степени и присваиваем им соответствующие значения для n = 0;
        % вспомогательная переменная для вычисления факториала
        fac = 1;
        % вспомогательная переменная для вычисления степеней x
        xPow =(x+1);
        % производим суммирование
        % функция abs возвращает модуль числа
        while abs(x_n) >= ep
            % вычисляем значение члена ряда
            x_n = x / fac;
            % производим суммирование
            y(i) = y(i) + x_n;
            % обновляем вспомогательные переменные для следующего члена
            n = n + 1;
            fac = fac *(2*n)*(2*n-1);
            xPow = xPow * (x+1)^(2*n);
        end
    end
end
% для построения графика создаем вектор значений аргумента
x = -3:0.001:0;
% строим график
plot(x,y) 
xlabel x
ylabel y
grid on
